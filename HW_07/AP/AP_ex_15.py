"""
Рекурсия хорошо подходит к задаче flattening. Это процесс выравнивания списков, который заключается в избавлении вложенной структуры.
Например список вида [1, 2, [3, 4, [5, 6]], 7] должен быть преобразован в плоский (flat) список [1, 2, 3, 4, 5, 6, 7]

Напишите функцию flatten, которая принимает на вход список, рекурсивно будет выравнивать этот список и возвращать плоскую версию списка.

Для выполнения задачи можно следовать следующему алгоритму:

Если входной список пуст, то:
  возвращаем пустой список
Если первый элемент списка является списком, то:
  Получаем первый список, рекурсивно вызвав функцию с первым элементом списка
  Получаем второй список, рекурсивно вызвав функцию с остальным списком без первого элемента
  Возвращаем конкатенацию двух списков
Если первый элемент списка не является списком, то:
  Получаем первый список с первого элемента списка
  Получаем второй список, рекурсивно вызвав функцию с остальным списком без первого элемента
  Возвращаем конкатенацию двух списков

вернуло [1, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10]
а надо  [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]
        [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]

"""

result_list = []

def flatten(data):
  
    if data == []:
        return data
    for i in data:
       if type(i) != list:
          result_list.append(i)
          
       if type(i) == list:
           flatten(i)
           
    return result_list



def main():
    
    daten = [1, [2, 3], [4, [5, [6, 7]]], [[[8], 9], [10]]]
    daten = [1, [2, [3, [4, [5, [6, [7, [8, [9, [10]]]]]]]]]]
    print(flatten(daten))

if __name__ == '__main__':
    main()


#############################
#### вот так надо
"""
def flatten(data):  
    if not data:  
        return []  
    if type(data[0]) == list:  
        return flatten(data[0]) + flatten(data[1:])  
    else:  
        return [data[0]] + flatten(data[1:])  
"""