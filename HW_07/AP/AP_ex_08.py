"""
Итоговая задача модуля два была на вычисление арифметического выражения. 
В задаче на повторение мы пойдем немного другим путем и выполним похожую задачу, заодно закрепив знания
по работе со строками и списками. Разбиение строки на лексемы представляет собой процесс преобразования
исходной строки в список из подстрок, называемых лексемами (token).

В арифметическом выражении лексемами являются: операторы, числа и скобки. Операторами у нас будут следующие символы:
 *, /, - и +. Операторы и скобки легко выделить в строке — они состоят из одного символа и никогда не являются частью других лексем.
Числа выделить сложнее, поскольку эти лексемы могут состоять из нескольких символов. 
Поэтому любая непрерывная последовательность цифр — это одна числовая лексема.

Напишите функцию, принимающую в качестве параметра строку, содержащую математическое выражение,
и преобразующую ее в список лексем. Каждая лексема должна быть либо оператором, либо числом, либо скобкой.

Пример:

"2+ 34 -5 * 3" => ['2', '+', '34', '-', '5', '*', '3']
В целях упрощения считаем, что числа могут быть только целыми, и входная строка
всегда будет содержать математическое выражение, состоящее из скобок, чисел и операторов.

Обратите внимание, что лексемы могут отделяться друг от друга разным количеством пробелов,
а могут и не отделяться вовсе. Пробелы не являются лексемами и в итоговый список попасть не должны.
"""


def token_parser(s):
    all_in_one = []
    s = s.split(" ")
    
    def element_parser(list_element:list):
        ln = list_element
        dig = ''
        if len(ln) == 1:
            all_in_one.append(ln)
        else:
            if ln.isdigit() == False:
              dig = ''  
            for ch in ln:
                
                if ch in ('()*/-+'):
                    if dig != '':
                        all_in_one.append(dig) 
                        dig = ''
                    all_in_one.append(ch)
                    continue
                if ch not in ('()*/-+'):
                    dig = dig + ch
                    continue
        if dig != '':
            all_in_one.append(dig)
    for token_element in s:
        element_parser(token_element)
    return all_in_one


def main():
   lex_string = '2+ 34 -5 * 34 +14 -14' 
   print(token_parser(lex_string))

if __name__ == '__main__':
    main()


"""
def token_parser(s):
   return re.findall(r'\d+|[\(\)+\-*/]', s)
"""